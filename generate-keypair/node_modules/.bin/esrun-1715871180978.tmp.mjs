process.argv = [process.argv[0], ...process.argv.slice(3)];

		import __esrun_url from 'url';

		import { createRequire as __esrun_createRequire } from "module";

		const __esrun_fileUrl = __esrun_url.pathToFileURL("\Solana\generate-keypair\node_modules\.bin\esrun-1715871180978.tmp.mjs");

		const require = __esrun_createRequire(__esrun_fileUrl);
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});

// transfer.ts
import { Connection, PublicKey, Transaction, SystemProgram, sendAndConfirmTransaction } from "../../node_modules/@solana/web3.js/lib/index.cjs.js";
import { getKeypairFromEnvironment } from "../../node_modules/@solana-developers/helpers/dist/index.js";
__require("./node_modules/dotenv/lib/main.js").config();
var suppliedToPubkey = process.argv[2] || null;
if (!suppliedToPubkey) {
  console.log(`Please provide a public key to send to`);
  process.exit(1);
}
var senderKeypair = getKeypairFromEnvironment("SECRET_KEY");
console.log(`suppliedToPubkey: ${suppliedToPubkey}`);
var toPubkey = new PublicKey(suppliedToPubkey);
var connection = new Connection("https://api.devnet.solana.com", "confirmed");
console.log(
  `\u2705 Loaded our own keypair, the destination public key, and connected to Solana`
);
var tx = new Transaction();
var LAMPORTS_TO_SEND = 100;
var sendSolInstruction = SystemProgram.transfer({
  fromPubkey: senderKeypair.publicKey,
  toPubkey,
  lamports: LAMPORTS_TO_SEND
});
tx.add(sendSolInstruction);
var signature = await sendAndConfirmTransaction(connection, tx, [
  senderKeypair
]);
console.log(
  `\u{1F4B8} Finished! Sent ${LAMPORTS_TO_SEND} to the address ${toPubkey}`
);
console.log(`Transaction signature is ${signature}!`);
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsidHJhbnNmZXIudHMiXSwKICAic291cmNlUm9vdCI6ICJDOlxcU29sYW5hXFxnZW5lcmF0ZS1rZXlwYWlyIiwKICAic291cmNlc0NvbnRlbnQiOiBbImltcG9ydCB7IENvbm5lY3Rpb24sIFB1YmxpY0tleSwgVHJhbnNhY3Rpb24sIFN5c3RlbVByb2dyYW0sIHNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24gfSBmcm9tIFwiQHNvbGFuYS93ZWIzLmpzXCI7XHJcbnJlcXVpcmUoJ2RvdGVudicpLmNvbmZpZygpO1xyXG5pbXBvcnQgeyBnZXRLZXlwYWlyRnJvbUVudmlyb25tZW50IH0gZnJvbSBcIkBzb2xhbmEtZGV2ZWxvcGVycy9oZWxwZXJzXCI7XHJcblxyXG5cclxuY29uc3Qgc3VwcGxpZWRUb1B1YmtleSA9IHByb2Nlc3MuYXJndlsyXSB8fCBudWxsO1xyXG5pZiAoIXN1cHBsaWVkVG9QdWJrZXkpIHtcclxuICBjb25zb2xlLmxvZyhgUGxlYXNlIHByb3ZpZGUgYSBwdWJsaWMga2V5IHRvIHNlbmQgdG9gKTtcclxuICBwcm9jZXNzLmV4aXQoMSk7XHJcbn1cclxuXHJcbmNvbnN0IHNlbmRlcktleXBhaXIgPSBnZXRLZXlwYWlyRnJvbUVudmlyb25tZW50KFwiU0VDUkVUX0tFWVwiKTtcclxuXHJcbmNvbnNvbGUubG9nKGBzdXBwbGllZFRvUHVia2V5OiAke3N1cHBsaWVkVG9QdWJrZXl9YCk7XHJcblxyXG5jb25zdCB0b1B1YmtleSA9IG5ldyBQdWJsaWNLZXkoc3VwcGxpZWRUb1B1YmtleSk7XHJcblxyXG5jb25zdCBjb25uZWN0aW9uID0gbmV3IENvbm5lY3Rpb24oXCJodHRwczovL2FwaS5kZXZuZXQuc29sYW5hLmNvbVwiLCBcImNvbmZpcm1lZFwiKTtcclxuXHJcblxyXG5jb25zb2xlLmxvZyhcclxuICBgXHUyNzA1IExvYWRlZCBvdXIgb3duIGtleXBhaXIsIHRoZSBkZXN0aW5hdGlvbiBwdWJsaWMga2V5LCBhbmQgY29ubmVjdGVkIHRvIFNvbGFuYWBcclxuKTtcclxuXHJcblxyXG5cclxuY29uc3QgdHggPSBuZXcgVHJhbnNhY3Rpb24oKTtcclxuXHJcbmNvbnN0IExBTVBPUlRTX1RPX1NFTkQgPSAxMDA7XHJcblxyXG5cclxuY29uc3Qgc2VuZFNvbEluc3RydWN0aW9uID0gU3lzdGVtUHJvZ3JhbS50cmFuc2Zlcih7XHJcbiAgZnJvbVB1YmtleTogc2VuZGVyS2V5cGFpci5wdWJsaWNLZXksXHJcbiAgdG9QdWJrZXksXHJcbiAgbGFtcG9ydHM6IExBTVBPUlRTX1RPX1NFTkQsXHJcbn0pO1xyXG5cclxuXHJcbnR4LmFkZChzZW5kU29sSW5zdHJ1Y3Rpb24pO1xyXG5cclxuY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgc2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbihjb25uZWN0aW9uLCB0eCwgW1xyXG4gIHNlbmRlcktleXBhaXIsXHJcbl0pO1xyXG5cclxuY29uc29sZS5sb2coXHJcbiAgYFx1RDgzRFx1RENCOCBGaW5pc2hlZCEgU2VudCAke0xBTVBPUlRTX1RPX1NFTkR9IHRvIHRoZSBhZGRyZXNzICR7dG9QdWJrZXl9YCBcclxuKTtcclxuY29uc29sZS5sb2coYFRyYW5zYWN0aW9uIHNpZ25hdHVyZSBpcyAke3NpZ25hdHVyZX0hYCk7Il0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7O0FBQUEsU0FBUyxZQUFZLFdBQVcsYUFBYSxlQUFlLGlDQUFpQztBQUU3RixTQUFTLGlDQUFpQztBQUQxQyxVQUFRLG1DQUFRLEVBQUUsT0FBTztBQUl6QixJQUFNLG1CQUFtQixRQUFRLEtBQUssQ0FBQyxLQUFLO0FBQzVDLElBQUksQ0FBQyxrQkFBa0I7QUFDckIsVUFBUSxJQUFJLHdDQUF3QztBQUNwRCxVQUFRLEtBQUssQ0FBQztBQUNoQjtBQUVBLElBQU0sZ0JBQWdCLDBCQUEwQixZQUFZO0FBRTVELFFBQVEsSUFBSSxxQkFBcUIsa0JBQWtCO0FBRW5ELElBQU0sV0FBVyxJQUFJLFVBQVUsZ0JBQWdCO0FBRS9DLElBQU0sYUFBYSxJQUFJLFdBQVcsaUNBQWlDLFdBQVc7QUFHOUUsUUFBUTtBQUFBLEVBQ047QUFDRjtBQUlBLElBQU0sS0FBSyxJQUFJLFlBQVk7QUFFM0IsSUFBTSxtQkFBbUI7QUFHekIsSUFBTSxxQkFBcUIsY0FBYyxTQUFTO0FBQUEsRUFDaEQsWUFBWSxjQUFjO0FBQUEsRUFDMUI7QUFBQSxFQUNBLFVBQVU7QUFDWixDQUFDO0FBR0QsR0FBRyxJQUFJLGtCQUFrQjtBQUV6QixJQUFNLFlBQVksTUFBTSwwQkFBMEIsWUFBWSxJQUFJO0FBQUEsRUFDaEU7QUFDRixDQUFDO0FBRUQsUUFBUTtBQUFBLEVBQ04sNEJBQXFCLG1DQUFtQztBQUMxRDtBQUNBLFFBQVEsSUFBSSw0QkFBNEIsWUFBWTsiLAogICJuYW1lcyI6IFtdCn0K

	